---
title: "Meterological Source Comparison"
author: "Cady B"
format: 
  html:
    toc: true
    code-fold: true
    df-print: paged
Params:
   lake_id: "rotorua"
   reference: "Airport_1770"
   targets: ["ERA5", "Buoy", "Town_40177", "VCS_On"]
   vars: ["Temp_C", "Precip_mm", "Wind_Spd_ms", "RadSWD_Wm2"]
  wet_threshold_mm: 1
  windy_top_pct: 0.10         # set null to use fixed windy_threshold_ms
  windy_threshold_ms: 10
  window_days: 30
execute:
  echo: true
  warning: false
  message: false
editor: visual
---

```{r}
library(here)

getwd()
here::here()
list.files(here::here())
list.files(here::here("scripts"))
file.exists(here::here("scripts", "00_metrics_helpers.R"))

```

```{r}
library(here)

# Force project root detection
here::i_am("MET_Lake_Comp_R.Rproj")

# Safety checks (fail fast, clearly)
stopifnot(
  file.exists(here("scripts", "00_metrics_helpers.R")),
  file.exists(here("scripts", "02_analysis_helpers.R"))
)

source(here("scripts", "00_metrics_helpers.R"))
source(here("scripts", "02_analysis_helpers.R"))

```

```{r}
# install.packages("here")
# We are using (calling out) pre set up scripts. But, quarto is in reports folder so we need to direst is "here" to the scripts foulder


library(tidyverse)
library(lubridate)
library(slider)
library(gt)
library(glue)
library(here)


# load your helper scripts (paths must match your project)
source(here("scripts", "00_metrics_helpers.R")) 
source(here("scripts", "02_analysis_helpers.R"))
source(here("scripts", "03_analysis_plotting.R"))




# --- file map (keep this until you standardise names) ---
file_map <- list(
  "ERA5"         = "data/processed/rotorua_era5_daily.csv",
  "Buoy"         = "data/processed/rotorua_buoy_daily.csv",
  "Town_40177"   = "data/processed/rotorua_town_40177_daily.csv",
  "VCS_On"       = "data/processed/rotorua_vcs_on_daily.csv",
  "Airport_1770" = "data/processed/rotorua_airport_1770_daily.csv"
)

read_from_map <- function(name) {
  read_csv(file_map[[name]], show_col_types = FALSE) |>
    mutate(Date = as.Date(Date))
}

# ---- parameters ----
ref_name <- params$reference
vars <- params$vars
wet_threshold_mm <- params$wet_threshold_mm
windy_top_pct <- params$windy_top_pct
windy_threshold_ms <- params$windy_threshold_ms
window_days <- params$window_days

# ---- load ref + targets ----
ref_df <- read_from_map(ref_name)

targets_list <- setNames(
  lapply(params$targets, read_from_map),
  params$targets
)

```

```{r}

---

# 3) Compute `metrics_all` once (drives everything)

metrics_all <- purrr::imap_dfr(
  targets_list,
  ~ metrics_vs_ref(
    ref_df      = ref_df,
    target_df   = .x,
    target_name = .y,
    vars = vars,
    wet_threshold_mm    = wet_threshold_mm,
    windy_threshold_ms  = windy_threshold_ms,
    windy_top_pct       = windy_top_pct
  )
)

metrics_all
```

```{r}

---

# 4) Faceted Quarto table per variable (from `metrics_all`)

This gives you “one table per variable” without hand-editing.

make_metrics_table <- function(var_name) {

  tab <- metrics_all |>
    filter(var == var_name) |>
    select(target, subset, n, cor, slope, intercept, mae, rmse, ccc, bias, rel_bias, wind_threshold)

  gt(tab) |>
    fmt_number(columns = where(is.numeric), decimals = 3) |>
    tab_header(title = paste0("Performance metrics: ", var_name)) |>
    tab_spanner(
      label = "Error",
      columns = c(mae, rmse)
    ) |>
    tab_spanner(
      label = "Agreement",
      columns = c(cor, ccc)
    )
}

for (v in vars) {
  cat("\n\n")
  print(make_metrics_table(v))
}

```

```{r}

---

# 5) Plot set per variable (time series / distribution / scatter / rolling)

## 5.1 Time series: lines for non-precip, hydrograph for precip

make_long_overlap <- function(ref_df, targets_list, var, ref_name = "Reference") {

  ref_keep <- ref_df |>
    select(Date, value = all_of(var)) |>
    mutate(source = ref_name)

  targets_keep <- purrr::imap_dfr(targets_list, ~ .x |>
    select(Date, value = all_of(var)) |>
    mutate(source = .y))

  df <- bind_rows(ref_keep, targets_keep) |>
    drop_na(value)

  ref_dates <- ref_keep |>
    drop_na(value) |>
    distinct(Date)

  df |>
    semi_join(ref_dates, by = "Date")
}

plot_timeseries_var <- function(var) {
  df <- make_long_overlap(ref_df, targets_list, var, ref_name = ref_name)

  if (var == "Precip_mm") {
    ggplot(df, aes(Date, value, fill = source)) +
      geom_col(position = "identity", alpha = 0.6) +
      labs(title = "Precipitation hydrograph (overlap with reference)",
           x = NULL, y = "Precipitation (mm)", fill = "Dataset") +
      theme_bw()
  } else {
    ggplot(df, aes(Date, value, color = source)) +
      geom_line(alpha = 0.7) +
      labs(title = paste0(var, " time series (overlap with reference)"),
           x = NULL, y = var, color = "Dataset") +
      theme_bw()
  }
}

for (v in vars) print(plot_timeseries_var(v))

```

```{r}

---

## 5.2 Distributions: full vs wet-days-only for precip

plot_distribution <- function(var) {

  df <- make_long_overlap(ref_df, targets_list, var, ref_name = ref_name)

  if (var == "Precip_mm") {
    # All days distribution
    p_all <- ggplot(df, aes(value, fill = source)) +
      geom_histogram(bins = 40, alpha = 0.6, position = "identity") +
      labs(title = "Precipitation distribution (all overlapping days)",
           x = "Precipitation (mm)", y = "Count", fill = "Dataset") +
      theme_bw()

    # Wet days only (based on reference threshold)
    ref_wet_dates <- ref_df |>
      filter(!is.na(Precip_mm), Precip_mm > wet_threshold_mm) |>
      distinct(Date)

    df_wet <- df |>
      semi_join(ref_wet_dates, by = "Date")

    p_wet <- ggplot(df_wet, aes(value, fill = source)) +
      geom_histogram(bins = 40, alpha = 0.6, position = "identity") +
      labs(title = paste0("Precipitation distribution (wet days only: obs > ", wet_threshold_mm, " mm)"),
           x = "Precipitation (mm)", y = "Count", fill = "Dataset") +
      theme_bw()

    list(p_all, p_wet)
  } else {
    p <- ggplot(df, aes(value, color = source)) +
      geom_density() +
      labs(title = paste0(var, " density (overlap with reference)"),
           x = var, y = "Density", color = "Dataset") +
      theme_bw()
    list(p)
  }
}

for (v in vars) {
  plots <- plot_distribution(v)
  for (p in plots) print(p)
}

```

```{r}

---

# 6) Your scatter plots — **one figure**, faceted by target (ncol = 1)



plot_scatter_var_all_targets <- function(var) {

  df_all <- purrr::imap_dfr(targets_list, function(df_tgt, nm) {
    joined <- inner_join(
      ref_df |> select(Date, ref = all_of(var)),
      df_tgt |> select(Date, tgt = all_of(var)),
      by = "Date"
    ) |>
      drop_na(ref, tgt) |>
      mutate(target = nm)

    # compute annotations per facet (target)
    n_val    <- nrow(joined)
    cor_val  <- if (n_val > 1) cor(joined$ref, joined$tgt) else NA_real_
    rmse_val <- sqrt(mean((joined$tgt - joined$ref)^2))
    bias_val <- mean(joined$tgt - joined$ref)

    ann <- paste0(
      "n=", n_val,
      "\nR=", ifelse(is.na(cor_val), "NA", sprintf("%.2f", cor_val)),
      "\nRMSE=", sprintf("%.2f", rmse_val),
      "\nBias=", sprintf("%.2f", bias_val)
    )

    joined |> mutate(ann = ann)
  })

  ggplot(df_all, aes(ref, tgt)) +
    geom_point(alpha = 0.35) +
    geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
    geom_smooth(method = "lm", se = TRUE) +
    coord_equal() +
    facet_wrap(~ target, ncol = 1, scales = "free") +
    geom_text(aes(label = ann), x = Inf, y = -Inf, hjust = 1.05, vjust = -0.2) +
    labs(
      title = paste0(var, ": targets vs reference (", ref_name, ")"),
      x = paste0("Reference: ", ref_name),
      y = "Target"
    ) +
    theme_bw()
}

for (v in vars) print(plot_scatter_var_all_targets(v))

```

```{r}

**Note:** I did **not** force colors because you asked not to change too much. If you *do* want consistent colors by target, add `aes(color = target)` and `scale_color_manual(...)`.

---

# 7) Rolling MAE / RMSE / correlation (window is a parameter)

One figure per variable, faceted by target and metric (clean for Quarto).

rolling_metrics_one_target <- function(target_df, var, window_days) {

  joined <- inner_join(
    ref_df |> select(Date, ref = all_of(var)),
    target_df |> select(Date, tgt = all_of(var)),
    by = "Date"
  ) |>
    arrange(Date) |>
    drop_na(ref, tgt) |>
    mutate(err = tgt - ref)

  joined |>
    mutate(
      mae = slide_dbl(abs(err), mean, .before = window_days - 1, .complete = TRUE),
      rmse = slide_dbl(err^2, ~ sqrt(mean(.x)), .before = window_days - 1, .complete = TRUE),
      cor = slide_dbl(
        seq_along(ref),
        ~ cor(ref[pmax(1, .x - window_days + 1):.x],
              tgt[pmax(1, .x - window_days + 1):.x],
              use = "complete.obs"),
        .complete = TRUE
      )
    ) |>
    select(Date, mae, rmse, cor)
}

plot_rolling_all_targets <- function(var, window_days) {

  df_all <- purrr::imap_dfr(targets_list, function(df_tgt, nm) {
    rolling_metrics_one_target(df_tgt, var, window_days) |>
      mutate(target = nm)
  }) |>
    pivot_longer(c(mae, rmse, cor), names_to = "metric", values_to = "value")

  ggplot(df_all, aes(Date, value)) +
    geom_line() +
    facet_grid(metric ~ target, scales = "free_y") +
    labs(
      title = paste0("Rolling ", window_days, "-day performance vs ", ref_name, " (", var, ")"),
      x = NULL, y = NULL
    ) +
    theme_bw()
}

for (v in vars) print(plot_rolling_all_targets(v, window_days = window_days))

```

OVERVIEW

1.  loads packages + sources helper scripts

2.  reads `data/processed/*.csv` (don’t re-download raw data in the report)

```         
3.  generates:

    metrics tables

    plots (scatter, time series, distributions)

    short text interpretation + limitations
```

Reports should be stable and fast. Raw downloads + heavy cleaning belong in scripts, not the report.

Interactive doesn’t need to be complicated. Best options:

### A) Interactive tables (easy + high value)

Use **gt** (nice), or **DT** (sortable/searchable).

-   `gt` = publication-style

-   `DT::datatable()` = interactive table

-   You can do both:

-   show `gt` in the main report

-   offer a downloadable CSV and/or DT appendix

### B) Plot interactivity (optional)

If you want hover tooltips:

-   `plotly::ggplotly()` works well for scatter/time series\
    But I’d keep the *main* figures as static ggplot for publication quality, and add a “Interactive view” tab/section.

## Aim

This document compares multiple meterological data sources (ERA5, Buoy, NIWA VCS, Airport) for Lake Rotorua.

We evaluate

-   Correlation coefficent

-   Slope and intercept from linear regression

-   Mean absolute error (MAE)

-   Root mean squared error (RMSE)

-   Concordance correlation

## Metrics all - 20 01 26

```{r}
library(gt)

metrics_all |>
  arrange(var, target, subset) |>
  gt(groupname_col = "var") |>
  fmt_number(
    columns = c(cor, slope, intercept, mae, rmse, ccc, bias, rel_bias, wind_threshold),
    decimals = 3
  )

```

Note for above ; If you want prettier presentation, we can:

-   format `rel_bias` as percent

-   move `n` next to subset

-   hide `wind_threshold` for non-wind rows automatically

## Ensure data in every data set

```{r}
era5$Date <- as.Date(era5$Date)
buoy$Date <- as.Date(buoy$Date)
ap1770$Date <- as.Date(ap1770$Date)
twn40177$Date <- as.Date(twn40177$Date)
vcs_on$Date <- as.Date(vcs_on$Date)

```

### and Ensure the vars exist per dataset

If a dataset lacks radiation, your function will error. If that happens, we can add a tiny “available vars” filter, but don’t guess—run once and we’ll patch properly.

## Summary metrics - 19 01 26

```{r}
#| label: metrics-summary

metrics_all <- bind_rows(
calc_metrics(met$temp_airport, met$temp_era5)  |>
mutate(variable = "temp", source = "ERA5"),
calc_metrics(met$temp_airport, met$temp_buoy)  |>
mutate(variable = "temp", source = "Buoy"),
calc_metrics(met$temp_airport, met$temp_vcs)   |>
mutate(variable = "temp", source = "VCS")

# Add wind & rain comparisons similarly

) |>
relocate(variable, source)

metrics_all

```

## Scatter plots with Regression Lines

```{r}
#| label: fig-temp-scatter
#| fig-cap: "Temperature comparison vs Airport for Lake Rotorua."
#| fig-width: 7
#| fig-height: 4

ggplot(met, aes(x = temp_airport, y = temp_era5)) +
geom_point(alpha = 0.4) +
geom_smooth(method = "lm", se = TRUE) +
labs(
x = "Airport temperature (°C)",
y = "ERA5 temperature (°C)",
title = "ERA5 vs Airport temperature"
) +
theme_bw()

```

Note duplocate the above chunk for Buoy, VCS, wind, rain, etc

## Time series Example

```{r}
#| label: fig-temp-ts
#| fig-cap: "Daily temperature time series from multiple sources."

met_long_temp <- met |>
select(datetime, temp_airport, temp_era5, temp_buoy, temp_vcs) |>
pivot_longer(-datetime, names_to = "source", values_to = "temp")

ggplot(met_long_temp, aes(x = datetime, y = temp, colour = source)) +
geom_line(alpha = 0.7) +
labs(
x = "Date",
y = "Temperature (°C)",
colour = "Source",
title = "Temperature time series – Lake Rotorua"
) +
theme_bw()

```

TOO LOOK AT LATER \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_To render it:

-   Open `Rotorua_met_sources.qmd`
-   Click **Render** at the top\
    (or `Ctrl + Shift + P` → *Quarto: Render*)

You’ll get a nicely formatted HTML report.

------------------------------------------------------------------------

## Git & GitHub (project-level reproducibility)

Because you already have a `.git` folder, Git is initialised. Typical workflow:

After you do a chunk of work (e.g. create metrics script + Quarto doc):

1.  Open **Source Control** panel\

2.  Stage files (click `+` or “Stage All Changes”)\

3.  Write a message, e.g.:

    > "Add metrics helpers, data prep script, and first Quarto report"

4.  Click **Commit** ✔\

5.  Later, when you set up a GitHub repo, you’ll run:

    \`\`\`bash git remote add origin <https://github.com/yourname/LAKE_MET_WORKING.git> git push -u origin main

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ above look at later
